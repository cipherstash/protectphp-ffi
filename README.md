# Protect.php FFI

Protect.php FFI provides PHP bindings for the [CipherStash Client SDK](https://crates.io/crates/cipherstash-client) via PHP's [Foreign Function Interface (FFI)](https://www.php.net/manual/en/book.ffi.php).

Field-level encryption operations happen directly in your application with a unique key for each encrypted value, managed by CipherStash [ZeroKMS](https://cipherstash.com/products/zerokms) and backed by [AWS KMS](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html). The encrypted data can be stored in any database that supports JSONB.

> [!IMPORTANT]
> For most applications, you'll want to use the [Protect.php](https://github.com/cipherstash/protectphp) library instead, as it provides a more convenient API built on top of these bindings.

## Installation

Install Protect.php FFI via Composer:

```bash
composer require cipherstash/protectphp-ffi
```

## Requirements

Protect.php FFI requires PHP 8.1 or higher with the FFI extension (included in most distributions). This library includes prebuilt native libraries for the following platforms:

- macOS: Apple Silicon (ARM64) and Intel (x86_64) processors
- Linux: x86_64 and ARM64 architectures with GNU libc
- Windows: x86_64 architecture with MSVC runtime

## Configuration

Before using Protect.php FFI, you must configure your CipherStash credentials. Set these values in your application's environment variables:

```bash
CS_CLIENT_ID=your-client-id
CS_CLIENT_ACCESS_KEY=your-client-access-key
CS_CLIENT_KEY=your-client-key
CS_WORKSPACE_CRN=your-workspace-crn
```

Credentials can be generated by logging in or signing up for CipherStash and setting up a new workspace via the [CipherStash CLI](https://cipherstash.com/docs/sdk/how-to/cli) or [CipherStash Dashboard](https://dashboard.cipherstash.com/).

## Basic Usage

### Database Setup

Protect.php FFI works with any database that supports JSONB storage. The encrypted data is structured as an [Encrypt Query Language (EQL)](https://github.com/cipherstash/encrypt-query-language) JSON payload.

For advanced querying capabilities (searching, sorting, filtering), you'll need PostgreSQL with EQL support. EQL provides the `eql_v2_encrypted` type:

```sql
CREATE TABLE patient_records (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    email eql_v2_encrypted,
    systolic_bp eql_v2_encrypted,
    medical_notes eql_v2_encrypted,
    health_assessment eql_v2_encrypted,
    CONSTRAINT unique_email UNIQUE ((email->>'hm')) -- Enforce unique emails
);
```

See the [EQL installation instructions](https://github.com/cipherstash/encrypt-query-language#installation) to get started.

### Encryption Configuration

The encryption configuration defines your schema and determines what types of operations are supported on encrypted data. It consists of a JSON structure that specifies tables, columns, data types, and encryption indexes.

Basic structure:

```php
$config = [
    'v' => 2,
    'tables' => [
        'table_name' => [
            'column_name' => [
                'cast_as' => 'data_type',
                'indexes' => [
                    'unique' => [
                        'token_filters' => [
                            ['kind' => 'downcase'],
                        ],
                    ],
                    'match' => (object) [],
                ],
            ],
        ],
    ],
];
```

Configuration parameters:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `v` | `int` | ✓ | Schema version for backward compatibility (must be `2`) |
| `tables` | `object` | ✓ | Table definitions containing column configurations |
| `tables.<table_name>` | `object` | ✓ | Column definitions for the specified table |
| `tables.<table_name>.<column_name>` | `object` | ✓ | Configuration for the specified column |
| `tables.<table_name>.<column_name>.cast_as` | `string` | ✗ | Data type for processing before encryption (defaults to `text`) |
| `tables.<table_name>.<column_name>.indexes` | `object` | ✗ | Encryption indexes for query patterns |
| `tables.<table_name>.<column_name>.indexes.<index_type>` | `object` | ✗ | Configuration parameters for the specified index type (see individual index type documentation) |
| `tables.<table_name>.<column_name>.indexes.<index_type>.<param>` | `mixed` | ✗ | Index-specific configuration parameter |

> [!IMPORTANT]
> When configuring indexes without parameters, you must use `(object) []` instead of an empty array `[]`. This ensures PHP's `json_encode()` produces a JSON object (`{}`) rather than a JSON array (`[]`), which is required by the native library's configuration parser.

**Data Types**

The `cast_as` parameter determines how plaintext data is processed before encryption:

| Type | Description | Example Input |
|------|-------------|---------------|
| `text` | String data | `john@example.com` |
| `boolean` | Boolean values | `true` or `false` |
| `small_int` | 16-bit integer numbers | `32767` |
| `int` | 32-bit integer numbers | `2147483647` |
| `big_int` | 64-bit integer numbers | `9223372036854775807` |
| `real` | Single-precision floating point | `25.99` |
| `double` | Double-precision floating point | `3.141592653589793` |
| `date` | Date strings in ISO format | `2020-11-10` |
| `jsonb` | JSON data | `{"key": "value"}` |

**Index Types**

The `indexes` parameter determines what operations are supported on encrypted data:

| Index Type | Description | Response Parameter | Supported Queries |
|------------|-------------|-------------------|------------------|
| `unique` | Exact equality queries and uniqueness constraints | `hm` | `=` |
| `ore` | Equality, range comparisons, range queries, and ordering | `ob` | `=`, `>`, `<`, `BETWEEN`, `ORDER BY` |
| `match` | Full-text search queries | `bf` | `~~` |
| `ste_vec` | JSONB containment queries | `sv` | `@>`, `<@` |

**Unique Index (`unique`)**

Enables exact equality queries and database uniqueness constraints. Uses the `hm` response parameter to generate HMAC-based hashes for exact equality matching.

Basic usage:

```php
'patient_records' => [
    'email' => [
        'cast_as' => 'text',
        'indexes' => [
            'unique' => (object) [], // Uses defaults
        ],
    ],
],
```

Configuration parameters:

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `token_filters` | `array` | ✗ | `[]` | Text processing filters applied before hashing |
| `token_filters[].kind` | `string` | ✗ | - | Filter type: `downcase` to convert to lowercase |

With custom parameters:

```php
'patient_records' => [
    'email' => [
        'cast_as' => 'text',
        'indexes' => [
            'unique' => [
                'token_filters' => [
                    ['kind' => 'downcase'],
                ],
            ],
        ],
    ],
],
```

Example SQL query:

```sql
-- Find patient record by email address
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE email = '{"hm":"0f4f3b99671e74c0f8b5a1d2e3f4a5b6c7d8...","ob":null,"bf":null,"i":{"t":"patient_records","c":"email"}}'::jsonb;
```

For database-level uniqueness constraints, add a unique constraint on the `hm` response parameter:

```sql
CONSTRAINT unique_email UNIQUE ((email->>'hm'))
```

**Order Revealing Encryption Index (`ore`)**

Enables equality, range operations, and ordering on encrypted data. Uses the `ob` response parameter to create order-preserving encrypted values for equality checks, range comparisons, and sorting operations.

Basic usage:

```php
'patient_records' => [
    'systolic_bp' => [
        'cast_as' => 'int',
        'indexes' => [
            'ore' => (object) [],
        ],
    ],
],
```

Configuration parameters:

*This index type has no configurable parameters.*

Example SQL queries:

```sql
-- Find patients with exact blood pressure value
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE systolic_bp = '{"hm":null,"ob":["99f7adadadadadadc68b2822197a849e..."],"bf":null,"i":{"t":"patient_records","c":"systolic_bp"}}'::jsonb;

-- Find patients with blood pressure above specified threshold
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE systolic_bp >= '{"hm":null,"ob":["99f7adadadadadadc68b2822197a849e..."],"bf":null,"i":{"t":"patient_records","c":"systolic_bp"}}'::jsonb;

-- Find patients with blood pressure in specified range
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE systolic_bp BETWEEN
      '{"hm":null,"ob":["99f7adadadadadadc68b2822197a849e..."],"bf":null,"i":{"t":"patient_records","c":"systolic_bp"}}'::jsonb
  AND '{"hm":null,"ob":["99f7adadadadadadc68b2822197a849e..."],"bf":null,"i":{"t":"patient_records","c":"systolic_bp"}}'::jsonb;

-- Order patients by blood pressure from lowest to highest
SELECT * FROM patient_records
ORDER BY systolic_bp ASC;

-- Order patients by blood pressure from highest to lowest
SELECT * FROM patient_records
ORDER BY systolic_bp DESC;
```

**Match Index (`match`)**

Enables full-text search on encrypted text data using bloom filters. Uses the `bf` response parameter to create bloom filter representations of tokenized text for probabilistic matching.

Basic usage:

```php
'patient_records' => [
    'medical_notes' => [
        'cast_as' => 'text',
        'indexes' => [
            'match' => (object) [], // Uses defaults
        ],
    ],
],
```

Configuration parameters:

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `tokenizer` | `object` | ✗ | `{"kind": "standard"}` | Text tokenization method |
| `tokenizer.kind` | `string` | ✗ | `standard` | Tokenizer type: `standard` or `ngram` |
| `tokenizer.token_length` | `integer` | ✗ | `3` | Token length for ngram tokenizer |
| `token_filters` | `array` | ✗ | `[]` | Text processing filters |
| `token_filters[].kind` | `string` | ✗ | - | Filter type: `downcase` |
| `k` | `integer` | ✗ | `6` | Hash function count for bloom filter |
| `m` | `integer` | ✗ | `2048` | Bloom filter size in bits |
| `include_original` | `boolean` | ✗ | `false` | Include original text in search results |

With custom parameters:

```php
'patient_records' => [
    'medical_notes' => [
        'cast_as' => 'text',
        'indexes' => [
            'match' => [
                'tokenizer' => [
                    'kind' => 'ngram',
                    'token_length' => 3,
                ],
                'token_filters' => [
                    ['kind' => 'downcase'],
                ],
                'k' => 8,
                'm' => 1024,
                'include_original' => true,
            ],
        ],
    ],
],
```

Example SQL query:

```sql
-- Find patients with medical notes containing specified terms
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE medical_notes ~~ '{"hm":null,"ob":null,"bf":[1397,378,1463,1673,1474,1226],"i":{"t":"patient_records","c":"medical_notes"}}'::jsonb;
```

**Structured Text Encryption Vector Index (`ste_vec`)**

Enables containment queries on encrypted JSONB data. Uses the `sv` response parameter to create structured text encryption vectors that preserve JSON path relationships for encrypted JSONB containment matching.

Basic usage:

```php
'patient_records' => [
    'health_assessment' => [
        'cast_as' => 'jsonb',
        'indexes' => [
            'ste_vec' => [
                'prefix' => 'patient_records.health_assessment',
            ],
        ],
    ],
],
```

Configuration parameters:

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `prefix` | `string` | ✓ | - | Domain separator for cryptographic hashing that must be unique per column (recommended format is `table_name.column_name`) |

Example SQL queries:

```sql
-- Find records where encrypted data contains specified values
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE health_assessment @> '{"sv":[{"s":"dd4659b9c279af040dd05ce21b2a22f7...","t":"22303061363334333330316661653633...","r":"mBbL}QHJ&a(@rwS5n)u^G+Fb+t}Soo-h...","pa":false}],"i":{"t":"patient_records","c":"health_assessment"}}'::jsonb;

-- Find records where encrypted data is contained by specified values
-- Using search terms (encrypted ahead of time, plaintext not loggable):
SELECT * FROM patient_records
WHERE health_assessment <@ '{"sv":[{"s":"df08a4c4157bdb5bf6fa9be89cf18d10...","t":"22303063343133306135646334356130...","r":"mBbL}QHJ&a(@rwS5n)u^G+Fb+Ex8ofB!...","pa":false}],"i":{"t":"patient_records","c":"health_assessment"}}'::jsonb;
```

### Creating a Client

Create a client instance with your encryption configuration to perform encryption and decryption operations:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
            'systolic_bp' => [
                'cast_as' => 'int',
                'indexes' => [
                    'ore' => (object) [],
                ],
            ],
            'medical_notes' => [
                'cast_as' => 'text',
                'indexes' => [
                    'match' => (object) [],
                ],
            ],
            'health_assessment' => [
                'cast_as' => 'jsonb',
                'indexes' => [
                    'ste_vec' => [
                        'prefix' => 'patient_records.health_assessment',
                    ],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    // Your encryption operations go here...
} finally {
    // Always cleanup to prevent memory leaks
    $client->freeClient($clientPtr);
}
```

### Encrypting Data

Encrypt plaintext data for specific table columns using the `encrypt()` method. This method accepts a client pointer and individual parameters for the plaintext string, column name, and table name. The encryption configuration defines how each column should be encrypted and what data type it represents:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $encryptResultJson = $client->encrypt(
        client: $clientPtr,
        plaintext: 'john@example.com',
        columnName: 'email',
        tableName: 'patient_records',
    );

    $encryptResult = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    $ciphertext = $encryptResult['c'];

    echo $ciphertext;
    // mBbKlk}G7QdaGiNj$dL7#+AOrA^}*VJx...
} finally {
    $client->freeClient($clientPtr);
}
```

> [!IMPORTANT]
> The `plaintext` parameter must always be a string. The `cast_as` configuration parameter determines how the string is processed by the native library before encryption, not the input format, and indicates the intended data type for parsing decrypted strings. Convert all values to strings before calling this method.

#### Encryption Response

The `encrypt()` method returns a JSON string containing the encrypted data. The response format depends on the configured indexes.

**Standard Indexes Response**

For columns configured with the `unique`, `ore`, and/or `match` indexes:

```json
{
    "k": "ct",
    "c": "mBbKlk}G7QdaGiNj$dL7#+AOrA^}*VJx...",
    "dt": "text",
    "hm": "f3ca71fd39ae9d3d1d1fc25141bcb6da...",
    "ob": null,
    "bf": null,
    "i": {
        "t": "patient_records",
        "c": "email"
    },
    "v": 2
}
```

Response parameters:

| Parameter | Type | Source | Description |
|-----------|-----------|--------|-------------|
| `k` | `string` | Always | Key type identifier (always `ct` for ciphertext) |
| `c` | `string` | Always | Base85-encoded ciphertext containing the encrypted data |
| `dt` | `string` | Always | Data type for casting (from `cast_as` configuration parameter) |
| `hm` | `string\|null` | `unique` | HMAC index for exact equality queries and uniqueness constraints |
| `ob` | `array\|null` | `ore` | Order-revealing encryption index for range queries |
| `bf` | `array\|null` | `match` | Bloom filter index for full-text search queries |
| `i` | `object` | Always | Table and column identifier for this encrypted value: `{"t":"table_name","c":"column_name"}` |
| `v` | `int` | Always | Schema version for backward compatibility |

**STE Vec Index Response**

For columns configured with the `ste_vec` index:

```json
{
    "k": "sv",
    "c": "mBbLQ2^Io|1eh_K2*n^LSCVVQuGhkL>w...",
    "dt": "jsonb",
    "sv": [
        {
            "s": "dd4659b9c279af040dd05ce21b2a22f7...",
            "t": "22303061363334333330316661653633...",
            "r": "mBbLQ2^Io|1eh_K2*n^LSCVVQuGhkL>w...",
            "pa": false
        }
    ],
    "i": {
        "t": "patient_records",
        "c": "health_assessment"
    },
    "v": 2
}
```

Response parameters:

| Parameter | Type | Source | Description |
|-----------|------|--------|-------------|
| `k` | `string` | Always | Key type identifier (always `sv` for structured vector) |
| `c` | `string` | Always | Base85-encoded ciphertext containing the encrypted data |
| `dt` | `string` | Always | Data type for casting (from `cast_as` configuration parameter) |
| `sv` | `array` | `ste_vec` | Structured text encryption vector for JSONB containment queries |
| `sv[].s` | `string` | `ste_vec` | Tokenized selector representing the encrypted JSON path to the value |
| `sv[].t` | `string` | `ste_vec` | Encrypted term value for equality and order-preserving queries |
| `sv[].r` | `string` | `ste_vec` | Base85-encoded ciphertext containing the encrypted record data |
| `sv[].pa` | `boolean` | `ste_vec` | Whether the parent JSON element is an array |
| `i` | `object` | Always | Table and column identifier for this encrypted value: `{"t":"table_name","c":"column_name"}` |
| `v` | `int` | Always | Schema version for backward compatibility |

### Decrypting Data

Decrypt ciphertext back to its original plaintext using the `decrypt()` method. This method accepts a client pointer and the base85-encoded ciphertext string from the encryption response:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $encryptResultJson = $client->encrypt(
        client: $clientPtr,
        plaintext: 'john@example.com',
        columnName: 'email',
        tableName: 'patient_records',
    );

    $encryptResult = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    $ciphertext = $encryptResult['c'];

    $decryptResult = $client->decrypt($clientPtr, $ciphertext);

    echo $decryptResult;
    // john@example.com
} finally {
    $client->freeClient($clientPtr);
}
```

Returns the decrypted plaintext as a string.

### Encryption Context

Provide additional encryption context for an additional layer of security by binding encrypted data to specific contextual information of your choosing. This prevents data encrypted with one context from being decrypted with a different context, even when using the same encryption keys.

**Context Types**

The `context` parameter determines what contextual authentication is supported on encrypted data:

| Context Type | Supported Index Types | Description |
|--------------|----------------------|-------------|
| `identity_claim` | `unique`, `ore`, `match` | Identity-aware encryption using JWT claims (requires CTS authentication) |
| `tag` | `unique`, `ore`, `match` | Label-aware encryption using string tags |
| `value` | `unique`, `ore`, `match` | Attribute-aware encryption using key-value pairs |

> [!IMPORTANT]
> Encryption context is not supported with `ste_vec` indexes and will cause decryption to fail.

#### Identity Claim Context

Identity claim context binds encrypted data to specific user identities using JWT claims. This enables identity-aware encryption where data can only be decrypted by authenticated users who match the identity criteria.

Identity claim context requires [CipherStash Token Service (CTS)](https://cipherstash.com/docs/cts/about) authentication for both encryption and decryption operations. The FFI layer supports identity claim parsing but cannot perform cryptographic operations with identity claims without valid CTS tokens. Use the [Protect.php](https://github.com/cipherstash/protectphp) library for this type of encryption context.

#### Tag Context

Tag context binds encrypted data to specific string labels. This enables label-aware encryption where data can only be decrypted when the same tag context is provided:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $context = [
        'tag' => ['pii', 'hipaa'],
    ];

    $contextJson = json_encode($context, JSON_THROW_ON_ERROR);

    $encryptResultJson = $client->encrypt(
        client: $clientPtr,
        plaintext: 'john@example.com',
        columnName: 'email',
        tableName: 'patient_records',
        contextJson: $contextJson,
    );

    $encryptResult = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    $ciphertext = $encryptResult['c'];

    $decryptResult = $client->decrypt($clientPtr, $ciphertext, $contextJson);

    echo $decryptResult;
    // john@example.com
} finally {
    $client->freeClient($clientPtr);
}
```

#### Value Context

Value context binds encrypted data to specific key-value pairs. This enables attribute-aware encryption where data can only be decrypted when the same value context is provided:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $context = [
        'value' => [
            ['key' => 'tenant_id', 'value' => 'tenant_2ynTJf38e9HvuAO8jaX5kAyVaKI'],
            ['key' => 'role', 'value' => 'admin'],
        ],
    ];

    $contextJson = json_encode($context, JSON_THROW_ON_ERROR);

    $encryptResultJson = $client->encrypt(
        client: $clientPtr,
        plaintext: 'john@example.com',
        columnName: 'email',
        tableName: 'patient_records',
        contextJson: $contextJson,
    );

    $encryptResult = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    $ciphertext = $encryptResult['c'];

    $decryptResult = $client->decrypt($clientPtr, $ciphertext, $contextJson);

    echo $decryptResult;
    // john@example.com
} finally {
    $client->freeClient($clientPtr);
}
```

> [!WARNING]
> You must use the same context for both encryption and decryption operations. Wrong contexts will result in decryption failures.

### Bulk Operations

For improved performance when handling multiple records, use bulk encryption and decryption operations:

#### Bulk Encryption

Encrypt multiple plaintext strings using the `encryptBulk()` method. This method accepts a client pointer and a JSON array of objects, where each object specifies the `plaintext`, `column`, `table`, and optional `context` for encryption:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
            'medical_notes' => [
                'cast_as' => 'text',
                'indexes' => [
                    'match' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $items = [
        [
            'plaintext' => 'john@example.com',
            'column' => 'email',
            'table' => 'patient_records',
        ],
        [
            'plaintext' => 'Patient shows improvement in mobility and pain management.',
            'column' => 'medical_notes',
            'table' => 'patient_records',
        ],
    ];

    $itemsJson = json_encode($items, JSON_THROW_ON_ERROR);
    $encryptResultJson = $client->encryptBulk($clientPtr, $itemsJson);

    $encryptResults = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    foreach ($encryptResults as $encryptResult) {
        $ciphertext = $encryptResult['c'];

        echo $ciphertext;
        // mBbKuXT|+vBh~K2WV-!n5_W3DBFd4`Mp...
    }
} finally {
    $client->freeClient($clientPtr);
}
```

Returns a JSON array where each element follows the same structure as documented in the [Encryption Response](#encryption-response) section.

#### Bulk Decryption

Decrypt multiple ciphertext strings using the `decryptBulk()` method. This method accepts a client pointer and a JSON array of objects, where each object contains a `ciphertext` with the base85-encoded ciphertext string and an optional `context` for decryption:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
            'medical_notes' => [
                'cast_as' => 'text',
                'indexes' => [
                    'match' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $items = [
        [
            'plaintext' => 'john@example.com',
            'column' => 'email',
            'table' => 'patient_records',
            'context' => [
                'tag' => ['pii', 'hipaa'],
            ],
        ],
        [
            'plaintext' => 'Patient shows improvement in mobility and pain management.',
            'column' => 'medical_notes',
            'table' => 'patient_records',
        ],
    ];

    $itemsJson = json_encode($items, JSON_THROW_ON_ERROR);
    $encryptResultJson = $client->encryptBulk($clientPtr, $itemsJson);
    $encryptResults = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    $decryptItems = array_map(function ($item, $encryptResult) {
        $decryptItem = ['ciphertext' => $encryptResult['c']];

        if (isset($item['context'])) {
            $decryptItem['context'] = $item['context'];
        }

        return $decryptItem;
    }, $items, $encryptResults);

    $decryptItemsJson = json_encode($decryptItems, JSON_THROW_ON_ERROR);

    echo $decryptItemsJson;
    // [{"ciphertext":"mBbK>BcAYctW$Gy)vK2)Y$&nBBKz{oL1...","context":{"tag":["pii","hipaa"]}},{"ciphertext":"mBbJ<8tOEI+Z`KFUV`q&kmdWtO#DKxW|..."}]

    $decryptResultJson = $client->decryptBulk($clientPtr, $decryptItemsJson);

    echo $decryptResultJson;
    // ["john@example.com","Patient shows improvement in mobility and pain management."]

    $decryptResults = json_decode(json: $decryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);
} finally {
    $client->freeClient($clientPtr);
}
```

Returns a JSON array of decrypted plaintext strings in the same order as the input JSON array.

### Searchable Encryption

Create search terms that enable querying encrypted data without decryption using the `createSearchTerms()` method. This method accepts a client pointer and a JSON array of objects, where each object specifies the `plaintext`, `column`, `table`, and optional `context` for generating search terms:

```php
use CipherStash\Protect\FFI\Client;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
            'systolic_bp' => [
                'cast_as' => 'int',
                'indexes' => [
                    'ore' => (object) [],
                ],
            ],
        ],
    ],
];

$configJson = json_encode($config, JSON_THROW_ON_ERROR);
$clientPtr = $client->newClient($configJson);

try {
    $searchTerms = [
        [
            'plaintext' => 'john@example.com',
            'column' => 'email',
            'table' => 'patient_records',
            'context' => [
                'tag' => ['pii', 'hipaa'],
            ],
        ],
        [
            'plaintext' => '120',
            'column' => 'systolic_bp',
            'table' => 'patient_records',
        ],
    ];

    $searchTermsJson = json_encode($searchTerms, JSON_THROW_ON_ERROR);
    $searchTermsResultJson = $client->createSearchTerms($clientPtr, $searchTermsJson);
    $searchTermsResult = json_decode(json: $searchTermsResultJson, associative: true, flags: JSON_THROW_ON_ERROR);

    foreach ($searchTermsResult as $searchTerms) {
        echo json_encode($searchTerms);
        // {"hm":"f3ca71fd39ae9d3d1d1fc25141bcb6da...","ob":null,"bf":null,"i":{"t":"patient_records","c":"email"}}
    }
} finally {
    $client->freeClient($clientPtr);
}
```

This functionality integrates with [EQL](https://github.com/cipherstash/encrypt-query-language) and is currently only supported on PostgreSQL databases.

#### Search Terms Response

The `createSearchTerms()` method returns a JSON string containing search terms with only the encryption indexes (without the full ciphertext). The response format depends on the configured indexes.

**Standard Indexes Response**

For columns configured with `unique`, `ore`, and/or `match` indexes:

```json
{
    "hm": "f3ca71fd39ae9d3d1d1fc25141bcb6da...",
    "ob": null,
    "bf": null,
    "i": {
        "t": "patient_records",
        "c": "email"
    }
}
```

Response parameters:

| Parameter | Type | Source | Description |
|-----------|------|--------|-------------|
| `hm` | `string\|null` | `unique` | HMAC index for exact equality queries and uniqueness constraints |
| `ob` | `array\|null` | `ore` | Order-revealing encryption index for range queries |
| `bf` | `array\|null` | `match` | Bloom filter index for full-text search queries |
| `i` | `object` | Always | Table and column identifier for this encrypted value: `{"t":"table_name","c":"column_name"}` |

**STE Vec Index Response**

For columns configured with `ste_vec` indexes:

```json
{
    "sv": [
        {
            "s": "dd4659b9c279af040dd05ce21b2a22f7...",
            "t": "22303061363334333330316661653633...",
            "r": "mBbLkCZcaJ2U|G333rRC>f;r}uFEp7Tg...",
            "pa": false
        },
        {
            "s": "df08a4c4157bdb5bf6fa9be89cf18d10...",
            "t": "22303063343133306135646334356130...",
            "r": "mBbLkCZcaJ2U|G333rRC>f;r}E&d@?`;...",
            "pa": false
        }
    ],
    "i": {
        "t": "patient_records",
        "c": "health_assessment"
    }
}
```

Response parameters:

| Parameter | Type | Source | Description |
|-----------|------|--------|-------------|
| `sv` | `array` | `ste_vec` | Structured text encryption vector for JSONB containment queries |
| `sv[].s` | `string` | `ste_vec` | Tokenized selector representing the encrypted JSON path to the value |
| `sv[].t` | `string` | `ste_vec` | Encrypted term value for equality and order-preserving queries |
| `sv[].r` | `string` | `ste_vec` | Base85-encoded ciphertext containing the encrypted record data |
| `sv[].pa` | `boolean` | `ste_vec` | Whether the parent JSON element is an array |
| `i` | `object` | Always | Table and column identifier for this encrypted value: `{"t":"table_name","c":"column_name"}` |

### Error Handling

Protect.php FFI operations may throw `FFIException` instances when errors occur during encryption, decryption, or client operations. Proper error handling ensures your application can gracefully handle configuration issues, network problems, or invalid data scenarios.

#### Exception Types

All FFI operations throw `FFIException` instances that contain descriptive error messages:

```php
use CipherStash\Protect\FFI\Client;
use CipherStash\Protect\FFI\Exceptions\FFIException;

$client = new Client;

$config = [
    'v' => 2,
    'tables' => [
        'patient_records' => [
            'email' => [
                'cast_as' => 'text',
                'indexes' => [
                    'unique' => (object) [],
                ],
            ],
        ],
    ],
];

try {
    $configJson = json_encode($config, JSON_THROW_ON_ERROR);
    $clientPtr = $client->newClient($configJson);

    $encryptResultJson = $client->encrypt(
        client: $clientPtr,
        plaintext: 'john@example.com',
        columnName: 'email',
        tableName: 'patient_records',
    );

    $encryptResult = json_decode(json: $encryptResultJson, associative: true, flags: JSON_THROW_ON_ERROR);
    $ciphertext = $encryptResult['c'];

    echo $ciphertext;
    // mBbKlk}G7QdaGiNj$dL7#+AOrA^}*VJx...
} catch (FFIException $e) {
    error_log($e->getMessage());

    throw new \RuntimeException('Failed to process encrypted data.', 0, $e);
} finally {
    $client->freeClient($clientPtr);
}
```

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.
